use std::{fmt::Display, ops::Range};

use crate::{MemoryInterface, architecture::leon3::communication_interface::Leon3Error};

const PNP_BASE_ADDRESS: u32 = 0xFFFF_F000;
// bytes for each AHB record
const PNP_RECORD_SIZE: u32 = 32;
// 64 masters and 63 slaves
const PNP_NUM_RECORDS: u32 = 64 + 63;

#[derive(Debug)]
pub struct PlugnPlayState {
    devices: Vec<Record>,
}

#[derive(Debug, Clone)]
pub struct Record {
    pub device: Device,
    pub version: u8,
    pub irq: u8,
    pub address_spaces: Vec<AddressSpace>,
}

#[derive(Debug, Clone)]
pub struct AddressSpace {
    pub addresses: Range<u64>,
    pub prefetchable: bool,
    pub cacheable: bool,
    pub kind: AddressSpaceKind,
}

#[derive(Debug, Clone, Copy)]
enum AddressSpaceKind {
    ApbIO,
    AhbMemory,
    AhbIO,
}

impl AddressSpaceKind {
    fn try_from_bits(bits: u8) -> Result<Self, ()> {
        match bits {
            0b0001 => Ok(AddressSpaceKind::ApbIO),
            0b0010 => Ok(AddressSpaceKind::AhbMemory),
            0b0011 => Ok(AddressSpaceKind::AhbIO),
            _ => Err(()),
        }
    }
}

impl Record {
    fn from_data(data: &[u32; 8]) -> Option<Self> {
        let vendor_id = u8::try_from((data[0] & 0xFF00_0000) >> 24).unwrap();
        let device_id = u16::try_from((data[0] & 0x00FF_F000) >> 12).unwrap();
        let device = Device::from_ids(vendor_id, device_id);
        if device == Device::Reserved {
            // Vendor ID 0x00 is reserved to indicate that no core is present
            return None;
        }
        let version = u8::try_from((data[0] & 0x0000_03E0) >> 5).unwrap();
        let irq = u8::try_from(((data[0] & 0x0000_0C00) >> 5) | (data[0] & 0x0000_001F)).unwrap();
        let address_space = data[4..]
            .iter()
            .filter_map(|bar| AddressSpace::from_bar(*bar))
            .collect();

        Some(Self {
            device,
            version,
            irq,
            address_spaces: address_space,
        })
    }
}

impl AddressSpace {
    /// New address space decoded from Bank Address Record
    fn from_bar(bar: u32) -> Option<Self> {
        let mask = u16::try_from((bar & 0x0000_FFF0) >> 4).unwrap();
        if mask == 0 {
            // if MASK = 0, the BAR is disabled rather than occupying the full
            // AHB I/O address range
            return None;
        }
        let addr = u16::try_from((bar & 0xFFF0_0000) >> 20).unwrap();
        let kind =
            AddressSpaceKind::try_from_bits(u8::try_from(bar & 0x0000_000F).unwrap()).ok()?;
        let cacheable = ((bar & 0x0001_0000) >> 16) == 1;
        let prefetchable = ((bar & 0x0002_0000) >> 17) == 1;
        let addresses = match kind {
            AddressSpaceKind::ApbIO => {
                // mask of 0xFFF -> 0 trailing zeros -> 256 bytes
                // mask of 0xFFE -> 1 trailing zeros -> 512 bytes
                // mask of 0xFFC -> 2 trailing zeros -> 1024 bytes
                // ...
                let size = 2u64.pow(mask.trailing_zeros()) * 2u64.pow(8);
                let start_addr = u64::from(addr & mask) << 8;
                start_addr..(start_addr + size)
            }
            AddressSpaceKind::AhbMemory => {
                // mask of 0xFFF -> 0 trailing zeros -> 1 MB
                // mask of 0xFFE -> 1 trailing zeros -> 2 MB
                // mask of 0xFFC -> 2 trailing zeros -> 4 MB
                // ...
                let size = 2u64.pow(mask.trailing_zeros()) * 2u64.pow(20);
                let start_addr = u64::from(addr & mask) << 20;
                start_addr..(start_addr + size)
            }
            AddressSpaceKind::AhbIO => {
                // mask of 0xFFF -> 0 trailing zeros -> 256 bytes
                // mask of 0xFFE -> 1 trailing zeros -> 512 bytes
                // mask of 0xFFC -> 2 trailing zeros -> 1024 bytes
                // ...
                let size = 2u64.pow(mask.trailing_zeros()) * 2u64.pow(8);
                let start_addr = 0xFFF0_0000 + (u64::from(addr & mask) << 8);
                start_addr..(start_addr + size)
            }
        };
        Some(Self {
            addresses,
            prefetchable,
            cacheable,
            kind,
        })
    }
}

impl PlugnPlayState {
    // TODO(darsor) return Plugnplay specific error
    pub(crate) fn scan_plugnplay(mem: &mut dyn MemoryInterface) -> Result<Self, crate::Error> {
        let devices = (0..PNP_NUM_RECORDS)
            .map(|record_idx| PNP_BASE_ADDRESS + record_idx * PNP_RECORD_SIZE)
            .map(|record_address| -> Result<_, crate::Error> {
                let mut record_data = [0u32; 8];
                mem.read_32(u64::from(record_address), &mut record_data)
                    .map_err(|err| Leon3Error::PlugnPlayFailure {
                        source: Box::new(err),
                    })?;
                Ok(record_data)
            })
            .filter_map(|record_data| match record_data {
                Ok(data) => Record::from_data(&data).map(Ok),
                Err(e) => Some(Err(e)),
            })
            .collect::<Result<Vec<_>, _>>()
            .map_err(|err| Leon3Error::PlugnPlayFailure {
                source: Box::new(err),
            })?;
        tracing::info!("Plug&Play scan complete: {devices:#?}");
        Ok(Self { devices })
    }

    pub(crate) fn find_device(&self, device: Device) -> Option<&Record> {
        self.devices.iter().find(|record| record.device == device)
    }
}

/// Vendor codes
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Device {
    Reserved,
    Gaisler(GaislerDevice),
    Unknown { vendor_id: u8, device_id: u16 },
}

impl Device {
    fn from_ids(vendor_id: u8, device_id: u16) -> Self {
        match vendor_id {
            0x00 => Self::Reserved,
            0x01 => Self::Gaisler(GaislerDevice::from_id(device_id)),
            _ => Self::Unknown {
                vendor_id,
                device_id,
            },
        }
    }
}

impl Display for Device {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Device::Reserved => write!(f, "Reserved"),
            Device::Gaisler(device) => write!(f, "Frontgrade Gaisler {device}"),
            Device::Unknown {
                vendor_id,
                device_id,
            } => write!(
                f,
                "Unknown (Vendor 0x{vendor_id:02X}, Device 0x{device_id:03X}"
            ),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum GaislerDevice {
    LEON2DSU,
    LEON3,
    LEON3DSU,
    ETHAHB,
    APBMST,
    AHBUART,
    SRCTRL,
    SDCTRL,
    SSRCTRL,
    I2C2AHB,
    APBUART,
    IRQMP,
    AHBRAM,
    AHBDPRAM,
    GRIOMMU2,
    GPTIMER,
    PCITRG,
    PCISBRG,
    PCIFBRG,
    PCITRACE,
    DMACTRL,
    AHBTRACE,
    DSUCTRL,
    CANAHB,
    GPIO,
    AHBROM,
    AHBJTAG,
    ETHMAC,
    SWNODE,
    SPW,
    AHB2AHB,
    USBDC,
    USB_DCL,
    DDRMP,
    ATACTRL,
    DDRSP,
    EHCI,
    UHCI,
    I2CMST,
    SPW2,
    AHBDMA,
    NUHOSP3,
    CLKGATE,
    SPICTRL,
    DDR2SP,
    SLINK,
    GRTM,
    GRTC,
    GRPW,
    GRCTM,
    GRHCAN,
    GRFIFO,
    GRADCDAC,
    GRPULSE,
    GRTIMER,
    AHB2PP,
    GRVERSION,
    APB2PW,
    PW2APB,
    GRCAN,
    I2CSLV,
    U16550,
    AHBMST_EM,
    AHBSLV_EM,
    GRTESTMOD,
    ASCS,
    IPMVBCTRL,
    SPIMCTRL,
    L4STAT,
    LEON4,
    LEON4DSU,
    PWM,
    L2CACHE,
    SDCTRL64,
    GR1553B,
    _1553TST,
    GRIOMMU,
    FTAHBRAM,
    FTSRCTRL,
    AHBSTAT,
    LEON3FT,
    FTMCTRL,
    FTSDCTRL,
    FTSRCTRL8,
    MEMSCRUB,
    FTSDCTRL64,
    NANDFCTRL,
    N2DLLCTRL,
    N2PLLCTRL,
    SPI2AHB,
    DDRSDMUX,
    AHBFROM,
    PCIEXP,
    APBPS2,
    VGACTRL,
    LOGAN,
    SVGACTRL,
    T1AHB,
    MP7WRAP,
    GRSYSMON,
    GRACECTRL,
    ATAHBSLV,
    ATAHBMST,
    ATAPBSLV,
    MIGDDR2,
    LCDCTRL,
    SWITCHOVER,
    FIFOUART,
    MUXCTRL,
    B1553BC,
    B1553RT,
    B1553BRM,
    AES,
    ECC,
    PCIF,
    CLKMOD,
    HAPSTRAK,
    TEST_1X2,
    WILD2AHB,
    BIO1,
    AESDMA,
    GRPCI2,
    GRPCI2_DMA,
    GRPCI2_TB,
    MMA,
    SATCAN,
    CANMUX,
    GRTMRX,
    GRTCTX,
    GRTMDESC,
    GRTMVC,
    GEFFE,
    GPREG,
    GRTMPAHB,
    SPWCUC,
    SPW2_DMA,
    SPWROUTER,
    EDCLMST,
    GRPWTX,
    GRPWRX,
    GPREGBANK,
    MIG_7SERIES,
    GRSPW2_SIST,
    SGMII,
    RGMII,
    IRQGEN,
    GRDMAC,
    AHB2AVLA,
    SPWTDP,
    L3STAT,
    GR740THS,
    GRRM,
    CMAP,
    CPGEN,
    AMBAPROT,
    IGLOO2_BRIDGE,
    AHB2AXI,
    AXI2AHB,
    FDIR_RSTCTRL,
    APB3MST,
    LRAM,
    BOOTSEQ,
    TCCOP,
    SPIMASTER,
    SPISLAVE,
    GRSRIO,
    AHBLM2AHB,
    AHBS2NOC,
    TCAU,
    GRTMDYNVCID,
    RNOCIRQPROP,
    FTADDR,
    ATG,
    DFITRACE,
    SELFTEST,
    DFIERRINJ,
    DFICHECK,
    GRCANFD,
    NIM,
    GRSHYLOC,
    GRTACHOM,
    L5STAT,
    LEON5,
    LEON5DSU,
    SPFI,
    RV64GC,
    RVDM,
    FTMCTRL2,
    GRDMAC2,
    GRSCRUB,
    GRPLIC,
    CLINT,
    SOCBRIDGE,
    NANDFCTRL2,
    DARE65THS,
    WIZL,
    HSSL,
    GRWATCHDOG,
    ETRACE,
    LEON5ADSU,
    LEON5DMAB,
    ACLINT,
    IMSIC,
    GRAPLIC,
    L2CL,
    L2CACHE_IO,
    AHB2AHB_STR,
    GRIOMMURV,
    SGMII_VCU118,
    APBUART_16550,
    IOPMP,
    EFPGA,
    GRISOC_MB_EXT,
    GRISOC_MB_INT,
    GRISOC_BOOT,
    GRISOC_CRYPTO,
    GRISOC_SRNG,
    GRPPSTIMER,
    GRLSEDC,
    MDIO_CTRL,
    OTP_WRPR,
    Unknown { device_id: u16 },
}

impl GaislerDevice {
    fn from_id(device_id: u16) -> Self {
        match device_id {
            0x002 => Self::LEON2DSU,
            0x003 => Self::LEON3,
            0x004 => Self::LEON3DSU,
            0x005 => Self::ETHAHB,
            0x006 => Self::APBMST,
            0x007 => Self::AHBUART,
            0x008 => Self::SRCTRL,
            0x009 => Self::SDCTRL,
            0x00A => Self::SSRCTRL,
            0x00B => Self::I2C2AHB,
            0x00C => Self::APBUART,
            0x00D => Self::IRQMP,
            0x00E => Self::AHBRAM,
            0x00F => Self::AHBDPRAM,
            0x010 => Self::GRIOMMU2,
            0x011 => Self::GPTIMER,
            0x012 => Self::PCITRG,
            0x013 => Self::PCISBRG,
            0x014 => Self::PCIFBRG,
            0x015 => Self::PCITRACE,
            0x016 => Self::DMACTRL,
            0x017 => Self::AHBTRACE,
            0x018 => Self::DSUCTRL,
            0x019 => Self::CANAHB,
            0x01A => Self::GPIO,
            0x01B => Self::AHBROM,
            0x01C => Self::AHBJTAG,
            0x01D => Self::ETHMAC,
            0x01E => Self::SWNODE,
            0x01F => Self::SPW,
            0x020 => Self::AHB2AHB,
            0x021 => Self::USBDC,
            0x022 => Self::USB_DCL,
            0x023 => Self::DDRMP,
            0x024 => Self::ATACTRL,
            0x025 => Self::DDRSP,
            0x026 => Self::EHCI,
            0x027 => Self::UHCI,
            0x028 => Self::I2CMST,
            0x029 => Self::SPW2,
            0x02A => Self::AHBDMA,
            0x02B => Self::NUHOSP3,
            0x02C => Self::CLKGATE,
            0x02D => Self::SPICTRL,
            0x02E => Self::DDR2SP,
            0x02F => Self::SLINK,
            0x030 => Self::GRTM,
            0x031 => Self::GRTC,
            0x032 => Self::GRPW,
            0x033 => Self::GRCTM,
            0x034 => Self::GRHCAN,
            0x035 => Self::GRFIFO,
            0x036 => Self::GRADCDAC,
            0x037 => Self::GRPULSE,
            0x038 => Self::GRTIMER,
            0x039 => Self::AHB2PP,
            0x03A => Self::GRVERSION,
            0x03B => Self::APB2PW,
            0x03C => Self::PW2APB,
            0x03D => Self::GRCAN,
            0x03E => Self::I2CSLV,
            0x03F => Self::U16550,
            0x040 => Self::AHBMST_EM,
            0x041 => Self::AHBSLV_EM,
            0x042 => Self::GRTESTMOD,
            0x043 => Self::ASCS,
            0x044 => Self::IPMVBCTRL,
            0x045 => Self::SPIMCTRL,
            0x047 => Self::L4STAT,
            0x048 => Self::LEON4,
            0x049 => Self::LEON4DSU,
            0x04A => Self::PWM,
            0x04B => Self::L2CACHE,
            0x04C => Self::SDCTRL64,
            0x04D => Self::GR1553B,
            0x04E => Self::_1553TST,
            0x04F => Self::GRIOMMU,
            0x050 => Self::FTAHBRAM,
            0x051 => Self::FTSRCTRL,
            0x052 => Self::AHBSTAT,
            0x053 => Self::LEON3FT,
            0x054 => Self::FTMCTRL,
            0x055 => Self::FTSDCTRL,
            0x056 => Self::FTSRCTRL8,
            0x057 => Self::MEMSCRUB,
            0x058 => Self::FTSDCTRL64,
            0x059 => Self::NANDFCTRL,
            0x05A => Self::N2DLLCTRL,
            0x05B => Self::N2PLLCTRL,
            0x05C => Self::SPI2AHB,
            0x05D => Self::DDRSDMUX,
            0x05E => Self::AHBFROM,
            0x05F => Self::PCIEXP,
            0x060 => Self::APBPS2,
            0x061 => Self::VGACTRL,
            0x062 => Self::LOGAN,
            0x063 => Self::SVGACTRL,
            0x064 => Self::T1AHB,
            0x065 => Self::MP7WRAP,
            0x066 => Self::GRSYSMON,
            0x067 => Self::GRACECTRL,
            0x068 => Self::ATAHBSLV,
            0x069 => Self::ATAHBMST,
            0x06A => Self::ATAPBSLV,
            0x06B => Self::MIGDDR2,
            0x06C => Self::LCDCTRL,
            0x06D => Self::SWITCHOVER,
            0x06E => Self::FIFOUART,
            0x06F => Self::MUXCTRL,
            0x070 => Self::B1553BC,
            0x071 => Self::B1553RT,
            0x072 => Self::B1553BRM,
            0x073 => Self::AES,
            0x074 => Self::ECC,
            0x075 => Self::PCIF,
            0x076 => Self::CLKMOD,
            0x077 => Self::HAPSTRAK,
            0x078 => Self::TEST_1X2,
            0x079 => Self::WILD2AHB,
            0x07A => Self::BIO1,
            0x07B => Self::AESDMA,
            0x07C => Self::GRPCI2,
            0x07D => Self::GRPCI2_DMA,
            0x07E => Self::GRPCI2_TB,
            0x07F => Self::MMA,
            0x080 => Self::SATCAN,
            0x081 => Self::CANMUX,
            0x082 => Self::GRTMRX,
            0x083 => Self::GRTCTX,
            0x084 => Self::GRTMDESC,
            0x085 => Self::GRTMVC,
            0x086 => Self::GEFFE,
            0x087 => Self::GPREG,
            0x088 => Self::GRTMPAHB,
            0x089 => Self::SPWCUC,
            0x08A => Self::SPW2_DMA,
            0x08B => Self::SPWROUTER,
            0x08C => Self::EDCLMST,
            0x08D => Self::GRPWTX,
            0x08E => Self::GRPWRX,
            0x08F => Self::GPREGBANK,
            0x090 => Self::MIG_7SERIES,
            0x091 => Self::GRSPW2_SIST,
            0x092 => Self::SGMII,
            0x093 => Self::RGMII,
            0x094 => Self::IRQGEN,
            0x095 => Self::GRDMAC,
            0x096 => Self::AHB2AVLA,
            0x097 => Self::SPWTDP,
            0x098 => Self::L3STAT,
            0x099 => Self::GR740THS,
            0x09A => Self::GRRM,
            0x09B => Self::CMAP,
            0x09C => Self::CPGEN,
            0x09D => Self::AMBAPROT,
            0x09E => Self::IGLOO2_BRIDGE,
            0x09F => Self::AHB2AXI,
            0x0A0 => Self::AXI2AHB,
            0x0A1 => Self::FDIR_RSTCTRL,
            0x0A2 => Self::APB3MST,
            0x0A3 => Self::LRAM,
            0x0A4 => Self::BOOTSEQ,
            0x0A5 => Self::TCCOP,
            0x0A6 => Self::SPIMASTER,
            0x0A7 => Self::SPISLAVE,
            0x0A8 => Self::GRSRIO,
            0x0A9 => Self::AHBLM2AHB,
            0x0AA => Self::AHBS2NOC,
            0x0AB => Self::TCAU,
            0x0AC => Self::GRTMDYNVCID,
            0x0AD => Self::RNOCIRQPROP,
            0x0AE => Self::FTADDR,
            0x0B0 => Self::ATG,
            0x0B1 => Self::DFITRACE,
            0x0B2 => Self::SELFTEST,
            0x0B3 => Self::DFIERRINJ,
            0x0B4 => Self::DFICHECK,
            0x0B5 => Self::GRCANFD,
            0x0B6 => Self::NIM,
            0x0B7 => Self::GRSHYLOC,
            0x0B8 => Self::GRTACHOM,
            0x0B9 => Self::L5STAT,
            0x0BA => Self::LEON5,
            0x0BB => Self::LEON5DSU,
            0x0BC => Self::SPFI,
            0x0BD => Self::RV64GC,
            0x0BE => Self::RVDM,
            0x0BF => Self::FTMCTRL2,
            0x0C0 => Self::GRDMAC2,
            0x0C1 => Self::GRSCRUB,
            0x0C2 => Self::GRPLIC,
            0x0C3 => Self::CLINT,
            0x0C4 => Self::SOCBRIDGE,
            0x0C5 => Self::NANDFCTRL2,
            0x0C6 => Self::DARE65THS,
            0x0C7 => Self::WIZL,
            0x0C8 => Self::HSSL,
            0x0C9 => Self::GRWATCHDOG,
            0x0CA => Self::ETRACE,
            0x0CB => Self::LEON5ADSU,
            0x0CC => Self::LEON5DMAB,
            0x0CD => Self::ACLINT,
            0x0CE => Self::IMSIC,
            0x0CF => Self::GRAPLIC,
            0x0D0 => Self::L2CL,
            0x0D1 => Self::L2CACHE_IO,
            0x0D2 => Self::AHB2AHB_STR,
            0x0D3 => Self::GRIOMMURV,
            0x0D4 => Self::SGMII_VCU118,
            0x0D5 => Self::APBUART_16550,
            0x0D6 => Self::IOPMP,
            0x0D7 => Self::EFPGA,
            0x0D8 => Self::GRISOC_MB_EXT,
            0x0D9 => Self::GRISOC_MB_INT,
            0x0DA => Self::GRISOC_BOOT,
            0x0DB => Self::GRISOC_CRYPTO,
            0x0DC => Self::GRISOC_SRNG,
            0x0DD => Self::GRPPSTIMER,
            0x0DE => Self::GRLSEDC,
            0x0DF => Self::MDIO_CTRL,
            0x0E0 => Self::OTP_WRPR,
            _ => Self::Unknown { device_id },
        }
    }
}

impl Display for GaislerDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LEON2DSU => write!(f, "LEON2 Debug Support Unit"),
            Self::LEON3 => write!(f, "LEON3 SPARC V8 Processor"),
            Self::LEON3DSU => write!(f, "LEON3 Debug Support Unit"),
            Self::ETHAHB => write!(f, "OC ethernet AHB interface"),
            Self::AHBRAM => write!(f, "Single-port AHB SRAM module"),
            Self::AHBDPRAM => write!(f, "Dual-port AHB SRAM module"),
            Self::APBMST => write!(f, "AHB/APB Bridge"),
            Self::AHBUART => write!(f, "AHB Debug UART"),
            Self::SRCTRL => write!(f, "Simple SRAM Controller"),
            Self::SDCTRL => write!(f, "PC133 SDRAM Controller"),
            Self::SSRCTRL => write!(f, "Synchronous SRAM Controller"),
            Self::APBUART => write!(f, "Generic UART"),
            Self::IRQMP => write!(f, "Multi-processor Interrupt Ctrl."),
            Self::GPTIMER => write!(f, "Modular Timer Unit"),
            Self::PCITRG => write!(f, "Simple 32-bit PCI Target"),
            Self::PCISBRG => write!(f, "Simple 32-bit PCI Bridge"),
            Self::PCIFBRG => write!(f, "Fast 32-bit PCI Bridge"),
            Self::PCITRACE => write!(f, "32-bit PCI Trace Buffer"),
            Self::DMACTRL => write!(f, "PCI/AHB DMA controller"),
            Self::AHBTRACE => write!(f, "AMBA Trace Buffer"),
            Self::DSUCTRL => write!(f, "DSU/ETH controller"),
            Self::GRTM => write!(f, "CCSDS Telemetry Encoder"),
            Self::GRTC => write!(f, "CCSDS Telecommand Decoder"),
            Self::GRPW => write!(f, "PacketWire to AMBA AHB I/F"),
            Self::GRCTM => write!(f, "CCSDS Time Manager"),
            Self::GRHCAN => write!(f, "ESA HurriCANe CAN with DMA"),
            Self::GRFIFO => write!(f, "FIFO Controller"),
            Self::GRADCDAC => write!(f, "ADC / DAC Interface"),
            Self::GRPULSE => write!(f, "General Purpose I/O with Pulses"),
            Self::GRTIMER => write!(f, "Timer Unit with Latches"),
            Self::AHB2PP => write!(f, "AMBA AHB to Packet Parallel I/F"),
            Self::GRVERSION => write!(f, "Version and Revision Register"),
            Self::APB2PW => write!(f, "PacketWire Transmit Interface"),
            Self::PW2APB => write!(f, "PacketWire Receive Interface"),
            Self::GRCAN => write!(f, "CAN Controller with DMA"),
            Self::AHBMST_EM => write!(f, "AMBA Master Emulator"),
            Self::AHBSLV_EM => write!(f, "AMBA Slave Emulator"),
            Self::CANAHB => write!(f, "OC CAN AHB interface"),
            Self::GPIO => write!(f, "General Purpose I/O port"),
            Self::AHBROM => write!(f, "Generic AHB ROM"),
            Self::AHB2AHB => write!(f, "AHB-to-AHB Bridge"),
            Self::AHB2AHB_STR => write!(f, "AHB/AHB Stripe Bridge"),
            Self::AHBDMA => write!(f, "Simple AHB DMA controller"),
            Self::NUHOSP3 => write!(f, "Nuhorizons Spartan3 IO I/F"),
            Self::CLKGATE => write!(f, "Clock gating unit"),
            Self::FTAHBRAM => write!(f, "Generic FT AHB SRAM module"),
            Self::FTSRCTRL => write!(f, "Simple FT SRAM Controller"),
            Self::LEON3FT => write!(f, "LEON3FT SPARC V8 Processor"),
            Self::FTMCTRL => write!(f, "Memory controller with EDAC"),
            Self::FTSDCTRL => write!(f, "FT PC133 SDRAM Controller"),
            Self::FTSRCTRL8 => write!(f, "FT 8-bit SRAM/16-bit IO Ctrl"),
            Self::FTSDCTRL64 => write!(f, "64-bit FT SDRAM Controller"),
            Self::AHBSTAT => write!(f, "AHB Status Register"),
            Self::AHBJTAG => write!(f, "JTAG Debug Link"),
            Self::ETHMAC => write!(f, "GR Ethernet MAC"),
            Self::SWNODE => write!(f, "SpaceWire Node Interface"),
            Self::SPW => write!(f, "SpaceWire Serial Link"),
            Self::VGACTRL => write!(f, "VGA controller"),
            Self::APBPS2 => write!(f, "PS2 interface"),
            Self::LOGAN => write!(f, "On chip Logic Analyzer"),
            Self::SVGACTRL => write!(f, "SVGA frame buffer"),
            Self::T1AHB => write!(f, "Niagara T1 PCX/AHB bridge"),
            Self::B1553BC => write!(f, "AMBA Wrapper for Core1553BBC"),
            Self::B1553RT => write!(f, "AMBA Wrapper for Core1553BRT"),
            Self::B1553BRM => write!(f, "AMBA Wrapper for Core1553BRM"),
            Self::SATCAN => write!(f, "SatCAN controller"),
            Self::CANMUX => write!(f, "CAN Bus multiplexer"),
            Self::GRTMRX => write!(f, "CCSDS Telemetry Receiver"),
            Self::GRTCTX => write!(f, "CCSDS Telecommand Transmitter"),
            Self::GRTMDESC => write!(f, "CCSDS Telemetry Descriptor"),
            Self::GRTMVC => write!(f, "CCSDS Telemetry VC Generator"),
            Self::GRTMPAHB => write!(f, "CCSDS Telemetry VC AHB Input"),
            Self::GEFFE => write!(f, "Geffe Generator"),
            Self::SPWCUC => write!(f, "CCSDS CUC / SpaceWire I/F"),
            Self::GPREG => write!(f, "General Purpose Register"),
            Self::AES => write!(f, "Advanced Encryption Standard"),
            Self::AESDMA => write!(f, "AES 256 DMA"),
            Self::GRPCI2 => write!(f, "GRPCI2 PCI/AHB bridge"),
            Self::GRPCI2_DMA => write!(f, "GRPCI2 DMA interface"),
            Self::GRPCI2_TB => write!(f, "GRPCI2 Trace buffer"),
            Self::MMA => write!(f, "Memory Mapped AMBA"),
            Self::ECC => write!(f, "Elliptic Curve Cryptography"),
            Self::PCIF => write!(f, "AMBA Wrapper for CorePCIF"),
            Self::USBDC => write!(f, "GR USB 2.0 Device Controller"),
            Self::USB_DCL => write!(f, "USB Debug Communication Link"),
            Self::DDRMP => write!(f, "Multi-port DDR controller"),
            Self::ATACTRL => write!(f, "ATA controller"),
            Self::DDRSP => write!(f, "Single-port DDR266 controller"),
            Self::EHCI => write!(f, "USB Enhanced Host Controller"),
            Self::UHCI => write!(f, "USB Universal Host Controller"),
            Self::I2CMST => write!(f, "AMBA Wrapper for OC I2C-master"),
            Self::I2CSLV => write!(f, "I2C Slave"),
            Self::U16550 => write!(f, "Simple 16550 UART"),
            Self::SPICTRL => write!(f, "SPI Controller"),
            Self::DDR2SP => write!(f, "Single-port DDR2 controller"),
            Self::GRTESTMOD => write!(f, "Test report module"),
            Self::CLKMOD => write!(f, "CPU Clock Switching Ctrl module"),
            Self::SLINK => write!(f, "SLINK Master"),
            Self::HAPSTRAK => write!(f, "HAPS HapsTrak I/O Port"),
            Self::TEST_1X2 => write!(f, "HAPS TEST_1x2 interface"),
            Self::WILD2AHB => write!(f, "WildCard CardBus interface"),
            Self::BIO1 => write!(f, "Basic I/O board BIO1"),
            Self::ASCS => write!(f, "ASCS Master"),
            Self::SPW2 => write!(f, "GRSPW2 SpaceWire Serial Link"),
            Self::IPMVBCTRL => write!(f, "IPM-bus/MVBC memory controller"),
            Self::SPIMCTRL => write!(f, "SPI Memory Controller"),
            Self::L4STAT => write!(f, "LEON4 Statistics Unit"),
            Self::LEON4 => write!(f, "LEON4 SPARC V8 Processor"),
            Self::LEON4DSU => write!(f, "LEON4 Debug Support Unit"),
            Self::PWM => write!(f, "PWM generator"),
            Self::L2CACHE => write!(f, "L2-Cache Controller"),
            Self::L2CACHE_IO => write!(f, "L2-Cache Controller I/O Port"),
            Self::SDCTRL64 => write!(f, "64-bit PC133 SDRAM Controller"),
            Self::MP7WRAP => write!(f, "CoreMP7 wrapper"),
            Self::GRSYSMON => write!(f, "AMBA wrapper for System Monitor"),
            Self::GRACECTRL => write!(f, "System ACE I/F Controller"),
            Self::ATAHBSLV => write!(f, "AMBA Test Framework AHB Slave"),
            Self::ATAHBMST => write!(f, "AMBA Test Framework AHB Master"),
            Self::ATAPBSLV => write!(f, "AMBA Test Framework APB Slave"),
            Self::MIGDDR2 => write!(f, "Xilinx MIG DDR2 Controller"),
            Self::LCDCTRL => write!(f, "LCD Controller"),
            Self::SWITCHOVER => write!(f, "Switchover Logic"),
            Self::FIFOUART => write!(f, "UART with large FIFO"),
            Self::MUXCTRL => write!(f, "Analogue multiplexer control"),
            Self::GR1553B => write!(f, "MIL-STD-1553B Interface"),
            Self::_1553TST => write!(f, "MIL-STD-1553B Test Device"),
            Self::MEMSCRUB => write!(f, "AHB Memory Scrubber"),
            Self::GRIOMMU => write!(f, "IO Memory Management Unit"),
            Self::GRIOMMURV => write!(f, "RISC-V IO Memory Management Unit"),
            Self::SPW2_DMA => write!(f, "GRSPW Router DMA interface"),
            Self::SPWROUTER => write!(f, "GRSPW Router"),
            Self::EDCLMST => write!(f, "EDCL master interface"),
            Self::GRPWTX => write!(f, "PacketWire Transmitter with DMA"),
            Self::GRPWRX => write!(f, "PacketWire Receiver with DMA"),
            Self::GRIOMMU2 => write!(f, "IOMMU secondary master i/f"),
            Self::I2C2AHB => write!(f, "I2C to AHB Bridge"),
            Self::NANDFCTRL => write!(f, "NAND Flash Controller"),
            Self::NANDFCTRL2 => write!(f, "NAND Flash Controller 2"),
            Self::N2PLLCTRL => write!(f, "N2X PLL Dynamic Config. i/f"),
            Self::N2DLLCTRL => write!(f, "N2X DLL Dynamic Config. i/f"),
            Self::GPREGBANK => write!(f, "General Purpose Register Bank"),
            Self::SPI2AHB => write!(f, "SPI to AHB Bridge"),
            Self::DDRSDMUX => write!(f, "Muxed FT DDR/SDRAM controller"),
            Self::AHBFROM => write!(f, "Flash ROM Memory"),
            Self::PCIEXP => write!(f, "Xilinx PCI EXPRESS Wrapper"),
            Self::MIG_7SERIES => write!(f, "Xilinx MIG Controller"),
            Self::GRSPW2_SIST => write!(f, "GRSPW Router SIST"),
            Self::SGMII => write!(f, "XILINX SGMII Interface"),
            Self::SGMII_VCU118 => write!(f, "VCU118 SGMII Interface"),
            Self::RGMII => write!(f, "Gaisler RGMII Interface"),
            Self::IRQGEN => write!(f, "Interrupt generator"),
            Self::GRDMAC => write!(f, "GRDMAC DMA Controller"),
            Self::AHB2AVLA => write!(f, "Avalon-MM memory controller"),
            Self::SPWTDP => write!(f, "CCSDS TDP / SpaceWire I/F"),
            Self::L3STAT => write!(f, "LEON3 Statistics Unit"),
            Self::GR740THS => write!(f, "Temperature sensor"),
            Self::DARE65THS => write!(f, "DARE65T Temperature sensor"),
            Self::GRRM => write!(f, "Reconfiguration Module"),
            Self::CMAP => write!(f, "CCSDS Memory Access Protocol"),
            Self::CPGEN => write!(f, "Discrete Command Pulse Gen"),
            Self::AMBAPROT => write!(f, "AMBA Protection Unit"),
            Self::IGLOO2_BRIDGE => write!(f, "Microsemi SF2/IGLOO2 MSS/HPMS"),
            Self::AHB2AXI => write!(f, "AMBA AHB/AXI Bridge"),
            Self::AXI2AHB => write!(f, "AMBA AXI/AHB Bridge"),
            Self::FDIR_RSTCTRL => write!(f, "FDIR Reset Controller"),
            Self::APB3MST => write!(f, "AHB/APB3 Bridge"),
            Self::LRAM => write!(f, "Dual-port AHB(/CPU) On-Chip RAM"),
            Self::BOOTSEQ => write!(f, "Custom AHB sequencer"),
            Self::TCCOP => write!(f, "CCSDS Telecommand Decoder (COP)"),
            Self::SPIMASTER => write!(f, "Simple SPI Master"),
            Self::SPISLAVE => write!(f, "Dual-port SPI Slave"),
            Self::GRSRIO => write!(f, "Serial RapidIO Logical Layer"),
            Self::AHBLM2AHB => write!(f, "AHB-Lite master to AHB master"),
            Self::AHBS2NOC => write!(f, "AHB slave to NoC"),
            Self::TCAU => write!(f, "Authentication Unit"),
            Self::GRTMDYNVCID => write!(f, "CCSDS Telemetry Dynamic VCID"),
            Self::RNOCIRQPROP => write!(f, "RNoC Interrupt propagator"),
            Self::FTADDR => write!(f, "DDR2/DDR3 controller with EDAC"),
            Self::ATG => write!(f, "AMBA2 Test Pattern Generator"),
            Self::DFITRACE => write!(f, "DFI2.1 Trace Buffer"),
            Self::SELFTEST => write!(f, "TV selftest module"),
            Self::DFIERRINJ => write!(f, "DFI error injection module"),
            Self::DFICHECK => write!(f, "DFI timing check module"),
            Self::GRCANFD => write!(f, "CAN-FD Controller with DMA"),
            Self::NIM => write!(f, "Synchronous serial interface"),
            Self::GRSHYLOC => write!(f, "SHYLOC Compressor with DMA"),
            Self::GRTACHOM => write!(f, "Simple Digital Tachometer"),
            Self::L5STAT => write!(f, "LEON5 Statistics Unit"),
            Self::LEON5 => write!(f, "LEON5 SPARC V8 Processor"),
            Self::LEON5DSU => write!(f, "LEON5 Debug Support Unit"),
            Self::SPFI => write!(f, "GRSPFI SpaceFibre Serial Link"),
            Self::RV64GC => write!(f, "NOEL-V RISC-V Processor"),
            Self::RVDM => write!(f, "RISC-V Debug Module"),
            Self::FTMCTRL2 => write!(f, "Memory controller with EDAC"),
            Self::GRDMAC2 => write!(f, "GRDMAC2 DMA Controller"),
            Self::GRSCRUB => write!(f, "GRSCRUB FPGA Scrubber"),
            Self::GRPLIC => write!(f, "RISC-V PLIC"),
            Self::CLINT => write!(f, "RISC-V CLINT"),
            Self::SOCBRIDGE => write!(f, "SoC to SoC bridge"),
            Self::WIZL => write!(f, "GRWIZL WizardLink Serial Link"),
            Self::HSSL => write!(f, "GRHSSL SpaceFibre + WizardLink"),
            Self::GRWATCHDOG => write!(f, "Watchdog unit with sep clock"),
            Self::ETRACE => write!(f, "RISC-V E-trace encoder"),
            Self::LEON5ADSU => write!(f, "LEON5 Advanced Debug Unit"),
            Self::LEON5DMAB => write!(f, "LEON5 IOMMU and DMA bridge"),
            Self::ACLINT => write!(f, "RISC-V ACLINT"),
            Self::GRAPLIC => write!(f, "RISC-V APLIC"),
            Self::IMSIC => write!(f, "RISC-V IMSIC"),
            Self::L2CL => write!(f, "L2-Cache Controller - Lite"),
            Self::APBUART_16550 => write!(f, "Generic UART 16550"),
            Self::IOPMP => write!(f, "RISC-V IOPMP"),
            Self::EFPGA => write!(f, "AHB interface to eFPGA28RH_30K"),
            Self::GRISOC_MB_EXT => write!(f, "GRISoC Mailbox interface"),
            Self::GRISOC_MB_INT => write!(f, "GRISoC Mailbox interface (int)"),
            Self::GRISOC_BOOT => write!(f, "GRISoC Boot FSM"),
            Self::GRISOC_CRYPTO => write!(f, "GRISoC Crypto accelerator"),
            Self::GRISOC_SRNG => write!(f, "GRISoC Secure RNG"),
            Self::GRPPSTIMER => write!(f, "PPS Timer"),
            Self::MDIO_CTRL => write!(f, "Ethernet MDIO Controller"),
            Self::GRLSEDC => write!(f, "Lattice CRAM Scrubber"),
            Self::OTP_WRPR => write!(f, "OTP control wrapper"),
            Self::Unknown { device_id } => {
                write!(f, "Unknown Device (ID 0x{device_id:03X})")
            }
        }
    }
}
